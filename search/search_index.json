{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Saturn Saturn is a web development framework written in F# which implements the server-side MVC pattern. Many of its components and concepts will seem familiar to those of us with experience in other web frameworks like Ruby on Rails or Python\u2019s Django. It's heavily inspired by Elixir's Phoenix . Read more about why I've decided to create Saturn, and some of its design choices on my blog - http://kcieslak.io/Reinventing-MVC-for-web-programming-with-F Saturn rings Saturn itself is the top layer of a multi-layer system designed to create a flexible, productive environment for creating web applications. Kestrel and ASP.NET Core ASP.NET Core is a cross-platform, high-performance, open-source framework for building modern, cloud-based, Internet-connected applications Kestrel is a cross-platform web server for ASP.NET Core based on libuv, a cross-platform asynchronous I/O library Giraffe Giraffe is an F# micro web framework for building rich web applications. It has been heavily inspired and is similar to Suave , but has been specifically designed with ASP.NET Core in mind and can be plugged into the ASP.NET Core pipeline via middleware. Giraffe applications are composed of so-called HttpHandler functions which can be thought of as a mixture of Suave's WebParts and ASP.NET Core's middleware. Saturn moons Saturn is not only a library building on top of Giraffe, but also a set of opinionated tooling for scaffolding a whole project and then generating some boilerplate code. At the moment our template is using (by default): Dapper a simple, focused on performance object mapper for .Net that you can add in to your project and will extend your IDbConnection interface. Simple.Migrations Simple.Migrations is a simple bare-bones migration framework for .NET Core (.NET Standard 1.2 and .NET 4.5). It doesn't provide SQL generation, nor an out-of-the-box command-line tool, nor any other fancy feature. It does however provide a set of simple, extendable, and composable tools for integrating migrations into your application. Overview Built on top of the battle-tested ASP.NET Core foundation and the highly flexible, extendable model of Giraffe, Saturn provides high level abstractions, helpers and tools to enable high developer productivity, at the same time keeping high application performance provided by Kestrel and Giraffe. Saturn is made up of a number of distinct parts, each with its own purpose and role to play in building a web application. Application the start and end of the request life cycle handles all aspects of requests up until the point where the router takes over provides a core set of plugs to apply to all requests dispatches requests into a router enables application and hosting configuration Router parses incoming requests and dispatches them to the correct controller/action, passing parameters as needed provides helpers to generate route paths or urls to resources defines named pipelines through which we may pass our requests allow easy application of groups of plugs to a set of routes Controllers provide functions, called actions , to handle requests actions: prepare data and pass it into views invoke rendering via views perform redirects returns data as JSON or XML and much more Views render templates act as a presentation layer define helper functions, available in templates, to decorate data for presentation Channels [Not implemented yet] manage sockets for easy realtime communication are analogous to controllers except that they allow bi-directional communication with persistent connections Scaffolding scripts dotnet new template providing good starting point for new applications - https://github.com/SaturnFramework/Saturn.Template dotnet saturn CLI tool that controls migrations and let you easily scaffold new parts of application - https://github.com/SaturnFramework/Saturn.Dotnet How to contribute Imposter syndrome disclaimer : I want your help. No really, I do. There might be a little voice inside that tells you you're not ready; that you need to do one more tutorial, or learn another framework, or write a few more blog posts before you can help me with this project. I assure you, that's not the case. This project has some clear Contribution Guidelines and expectations that you can read here . The contribution guidelines outline the process that you'll need to follow to get a patch merged. By making expectations and process explicit, I hope it will make it easier for you to contribute. And you don't just have to write code. You can help out by writing documentation, tests, or even by giving feedback about this work. (And yes, that includes giving feedback about the contribution guidelines.) Thank you for contributing! Contributing and copyright The project is hosted on GitHub where you can report issues , fork the project and submit pull requests. The library is available under MIT license , which allows modification and redistribution for both commercial and non-commercial purposes.","title":"Home"},{"location":"#saturn","text":"Saturn is a web development framework written in F# which implements the server-side MVC pattern. Many of its components and concepts will seem familiar to those of us with experience in other web frameworks like Ruby on Rails or Python\u2019s Django. It's heavily inspired by Elixir's Phoenix . Read more about why I've decided to create Saturn, and some of its design choices on my blog - http://kcieslak.io/Reinventing-MVC-for-web-programming-with-F","title":"Saturn"},{"location":"#saturn-rings","text":"Saturn itself is the top layer of a multi-layer system designed to create a flexible, productive environment for creating web applications.","title":"Saturn rings"},{"location":"#kestrel-and-aspnet-core","text":"ASP.NET Core is a cross-platform, high-performance, open-source framework for building modern, cloud-based, Internet-connected applications Kestrel is a cross-platform web server for ASP.NET Core based on libuv, a cross-platform asynchronous I/O library","title":"Kestrel and ASP.NET Core"},{"location":"#giraffe","text":"Giraffe is an F# micro web framework for building rich web applications. It has been heavily inspired and is similar to Suave , but has been specifically designed with ASP.NET Core in mind and can be plugged into the ASP.NET Core pipeline via middleware. Giraffe applications are composed of so-called HttpHandler functions which can be thought of as a mixture of Suave's WebParts and ASP.NET Core's middleware.","title":"Giraffe"},{"location":"#saturn-moons","text":"Saturn is not only a library building on top of Giraffe, but also a set of opinionated tooling for scaffolding a whole project and then generating some boilerplate code. At the moment our template is using (by default):","title":"Saturn moons"},{"location":"#dapper","text":"a simple, focused on performance object mapper for .Net that you can add in to your project and will extend your IDbConnection interface.","title":"Dapper"},{"location":"#simplemigrations","text":"Simple.Migrations is a simple bare-bones migration framework for .NET Core (.NET Standard 1.2 and .NET 4.5). It doesn't provide SQL generation, nor an out-of-the-box command-line tool, nor any other fancy feature. It does however provide a set of simple, extendable, and composable tools for integrating migrations into your application.","title":"Simple.Migrations"},{"location":"#overview","text":"Built on top of the battle-tested ASP.NET Core foundation and the highly flexible, extendable model of Giraffe, Saturn provides high level abstractions, helpers and tools to enable high developer productivity, at the same time keeping high application performance provided by Kestrel and Giraffe. Saturn is made up of a number of distinct parts, each with its own purpose and role to play in building a web application. Application the start and end of the request life cycle handles all aspects of requests up until the point where the router takes over provides a core set of plugs to apply to all requests dispatches requests into a router enables application and hosting configuration Router parses incoming requests and dispatches them to the correct controller/action, passing parameters as needed provides helpers to generate route paths or urls to resources defines named pipelines through which we may pass our requests allow easy application of groups of plugs to a set of routes Controllers provide functions, called actions , to handle requests actions: prepare data and pass it into views invoke rendering via views perform redirects returns data as JSON or XML and much more Views render templates act as a presentation layer define helper functions, available in templates, to decorate data for presentation Channels [Not implemented yet] manage sockets for easy realtime communication are analogous to controllers except that they allow bi-directional communication with persistent connections Scaffolding scripts dotnet new template providing good starting point for new applications - https://github.com/SaturnFramework/Saturn.Template dotnet saturn CLI tool that controls migrations and let you easily scaffold new parts of application - https://github.com/SaturnFramework/Saturn.Dotnet","title":"Overview"},{"location":"#how-to-contribute","text":"Imposter syndrome disclaimer : I want your help. No really, I do. There might be a little voice inside that tells you you're not ready; that you need to do one more tutorial, or learn another framework, or write a few more blog posts before you can help me with this project. I assure you, that's not the case. This project has some clear Contribution Guidelines and expectations that you can read here . The contribution guidelines outline the process that you'll need to follow to get a patch merged. By making expectations and process explicit, I hope it will make it easier for you to contribute. And you don't just have to write code. You can help out by writing documentation, tests, or even by giving feedback about this work. (And yes, that includes giving feedback about the contribution guidelines.) Thank you for contributing!","title":"How to contribute"},{"location":"#contributing-and-copyright","text":"The project is hosted on GitHub where you can report issues , fork the project and submit pull requests. The library is available under MIT license , which allows modification and redistribution for both commercial and non-commercial purposes.","title":"Contributing and copyright"},{"location":"api/application/","text":"Application run Runs Saturn application Input: IWebHostBuilder Application builder Computation expression used to configure Saturn application. Under the hood it's using ASP.NET application configurations interfaces such as IWebHostBuilder , IServiceCollection , IApplicationBuilder and others. It aims to hide cumbersome ASP.NET application configuration and enable high level, declarative application configuration using feature toggles Example: let app = application { pipe_through endpointPipe use_router topRouter url http://0.0.0.0:8085/ memory_cache use_static static use_gzip } use_router Defines top-level router used for the application. It's calling IApplicationBuilder.UseGiraffe Input: HttpHandler application { ... use_router myRouter } pipe_through Adds pipeline to the list of pipelines that will be used for every request Input: HttpHandler application { ... pipe_through requestId } error_handler Adds global error handler for exceptions not handled anywhere else. It's using IApplicationBuilder.UseGiraffeErrorHandler Input: Exception - ILogger - HttpHandler application { ... error_handler (fun e log - text e.Message) } url Defines URL on which application will be hosted. Should include port. Input: string application { ... url http://0.0.0.0:8085/ } memory_cache Enables in-memory session cache. Required if you used fetchSession plug. application { ... memory_cache } use_gzip Enables automatic gzip compression application { ... use_gzip } use_static Enables using static file hosting. Input path defines WebRoot and ContentRoot of application Input: string application { ... use_static static } use_config Defines configuration that can be used with HttpContext.GetConfiguration () function. Configuration function is evaluated once, during first request of the application. Input: unit - 'a application { ... use_config (fun _ - config ) } force_ssl Redirect all HTTP request to HTTPS application { ... force_ssl } use_cors Enables application level CORS protection. First parameter is name of the policy. Second parameter is configuration builder setting policy options. Input: string - (CorsPolicyBuilder - unit) application { ... use_cors CORS_policy (fun builder - ()) } use_iis Enables IIS integration application { ... use_iis } use_jwt_authentication Enables default JWT authentication. First parameter is private key used to signing. Second one defines issuer of the token. Input: string - string application { ... use_jwt_authentication mySecretKey lambdafactory.io } use_jwt_authentication_with_config Enables JWT authentication with custom configuration Input: JwtBearerOptions - unit application { ... use_jwt_authentication_with_config (fun opts - ()) } use_cookies_authentication Enables default cookies authentication Input: string application { ... use_cookies_authentication lambdafactory.io } use_cookies_authentication_with_config Enables cookies authentication with custom configuration Input: CookieAuthenticationOptions - unit application { ... use_cookies_authentication_with_config (fun opts - ()) } use_github_oauth Enables default GitHub OAuth authentication Input: string - string - string application { ... use_github_oauth myClientId myClientSecret /login } use_github_oauth_with_config Enables GitHub OAuth authentication with custom configuration Input: OAuthOptions - unit application { ... use_github_oauth (fun opts - ()) } use_custom_oauth Enables custom OAuth authentication Input: string - (OAuthOptions - unit) application { ... use_custom_oauth LinkedIn (fun opts - ()) } Functions below enables you to add any configuration with using standard ASP.NET builders app_config Adds custom application configuration step. Input: IApplicationBuilder - IApplicationBuilder host_config Adds custom host configuration step. Input: IWebHostBuilder - IWebHostBuilder service_config Adds custom service configuration step. Input: IServiceCollection - IServiceCollection logging Adds logging configuration Input: IloggingBuilder - unit","title":"Application"},{"location":"api/application/#application","text":"","title":"Application"},{"location":"api/application/#run","text":"Runs Saturn application Input: IWebHostBuilder","title":"run"},{"location":"api/application/#application-builder","text":"Computation expression used to configure Saturn application. Under the hood it's using ASP.NET application configurations interfaces such as IWebHostBuilder , IServiceCollection , IApplicationBuilder and others. It aims to hide cumbersome ASP.NET application configuration and enable high level, declarative application configuration using feature toggles Example: let app = application { pipe_through endpointPipe use_router topRouter url http://0.0.0.0:8085/ memory_cache use_static static use_gzip }","title":"Application builder"},{"location":"api/application/#use_router","text":"Defines top-level router used for the application. It's calling IApplicationBuilder.UseGiraffe Input: HttpHandler application { ... use_router myRouter }","title":"use_router"},{"location":"api/application/#pipe_through","text":"Adds pipeline to the list of pipelines that will be used for every request Input: HttpHandler application { ... pipe_through requestId }","title":"pipe_through"},{"location":"api/application/#error_handler","text":"Adds global error handler for exceptions not handled anywhere else. It's using IApplicationBuilder.UseGiraffeErrorHandler Input: Exception - ILogger - HttpHandler application { ... error_handler (fun e log - text e.Message) }","title":"error_handler"},{"location":"api/application/#url","text":"Defines URL on which application will be hosted. Should include port. Input: string application { ... url http://0.0.0.0:8085/ }","title":"url"},{"location":"api/application/#memory_cache","text":"Enables in-memory session cache. Required if you used fetchSession plug. application { ... memory_cache }","title":"memory_cache"},{"location":"api/application/#use_gzip","text":"Enables automatic gzip compression application { ... use_gzip }","title":"use_gzip"},{"location":"api/application/#use_static","text":"Enables using static file hosting. Input path defines WebRoot and ContentRoot of application Input: string application { ... use_static static }","title":"use_static"},{"location":"api/application/#use_config","text":"Defines configuration that can be used with HttpContext.GetConfiguration () function. Configuration function is evaluated once, during first request of the application. Input: unit - 'a application { ... use_config (fun _ - config ) }","title":"use_config"},{"location":"api/application/#force_ssl","text":"Redirect all HTTP request to HTTPS application { ... force_ssl }","title":"force_ssl"},{"location":"api/application/#use_cors","text":"Enables application level CORS protection. First parameter is name of the policy. Second parameter is configuration builder setting policy options. Input: string - (CorsPolicyBuilder - unit) application { ... use_cors CORS_policy (fun builder - ()) }","title":"use_cors"},{"location":"api/application/#use_iis","text":"Enables IIS integration application { ... use_iis }","title":"use_iis"},{"location":"api/application/#use_jwt_authentication","text":"Enables default JWT authentication. First parameter is private key used to signing. Second one defines issuer of the token. Input: string - string application { ... use_jwt_authentication mySecretKey lambdafactory.io }","title":"use_jwt_authentication"},{"location":"api/application/#use_jwt_authentication_with_config","text":"Enables JWT authentication with custom configuration Input: JwtBearerOptions - unit application { ... use_jwt_authentication_with_config (fun opts - ()) }","title":"use_jwt_authentication_with_config"},{"location":"api/application/#use_cookies_authentication","text":"Enables default cookies authentication Input: string application { ... use_cookies_authentication lambdafactory.io }","title":"use_cookies_authentication"},{"location":"api/application/#use_cookies_authentication_with_config","text":"Enables cookies authentication with custom configuration Input: CookieAuthenticationOptions - unit application { ... use_cookies_authentication_with_config (fun opts - ()) }","title":"use_cookies_authentication_with_config"},{"location":"api/application/#use_github_oauth","text":"Enables default GitHub OAuth authentication Input: string - string - string application { ... use_github_oauth myClientId myClientSecret /login }","title":"use_github_oauth"},{"location":"api/application/#use_github_oauth_with_config","text":"Enables GitHub OAuth authentication with custom configuration Input: OAuthOptions - unit application { ... use_github_oauth (fun opts - ()) }","title":"use_github_oauth_with_config"},{"location":"api/application/#use_custom_oauth","text":"Enables custom OAuth authentication Input: string - (OAuthOptions - unit) application { ... use_custom_oauth LinkedIn (fun opts - ()) } Functions below enables you to add any configuration with using standard ASP.NET builders","title":"use_custom_oauth"},{"location":"api/application/#app_config","text":"Adds custom application configuration step. Input: IApplicationBuilder - IApplicationBuilder","title":"app_config"},{"location":"api/application/#host_config","text":"Adds custom host configuration step. Input: IWebHostBuilder - IWebHostBuilder","title":"host_config"},{"location":"api/application/#service_config","text":"Adds custom service configuration step. Input: IServiceCollection - IServiceCollection","title":"service_config"},{"location":"api/application/#logging","text":"Adds logging configuration Input: IloggingBuilder - unit","title":"logging"},{"location":"api/controller/","text":"Controller Controller helpers Module with high level helper functions that are usually used in controller actions. json Returns to the client content serialized to JSON Type: HttpContext - 'a - HttpFuncResult xml Returns to the client content serialized to XML. Type: HttpContext - 'a - HttpFuncResult text Returns to the client content as string. Type: HttpContext - string - HttpFuncResult render Returns to the client rendered template. Type: HttpContext - string - HttpFuncResult file Returns to the client static file. Type: HttpContext - string - HttpFuncResult sendDownload Sends file with given path Type: HttpContext - string - HttpFuncResult sendDownloadBinary Sends file as binary blob Type: HttpContext - byte [] - HttpFuncResult redirect Sends redirect response Type: HttpContext - string - HttpFuncResult getJson 'a Gets model from body as JSON. Type: HttpContext - Task 'a getXml 'a Gets model from body as XML. Type: HttpContext - Task 'a getForm 'a Gets model from urelencoded body. Type: HttpContext - Task 'a getQuery 'a Gets model from query string. Type: HttpContext - Task 'a getModel 'a Get model based on HttpMethod and Content-Type of request. Type: HttpContext - Task 'a loadModel 'a Loads model populated by fetchModel pipeline Type: HttpContext - Option 'a getPath Gets path of the request - it's relative to current router Type: HttpContext - string getUrl Gets url of the request Type: HttpContext - string option getConfig 'a Gets configuration Type: HttpContext - 'a Response helpers Module with lower level functions for returning certain responses from the action. continue Returns 100 Continue Type: HttpContext - HttpFuncResult switchingProto Returns 101 Switching Protocols Type: HttpContext - HttpFuncResult ok Returns 200 OK Type: HttpContext - 'a - HttpFuncResult created Returns 201 Created Type: HttpContext - 'a - HttpFuncResult accepted Returns 202 Accepted Type: HttpContext - 'a - HttpFuncResult badRequest Returns 400 Bad Request Type: HttpContext - 'a - HttpFuncResult unauthorized Returns 401 Unauthorized . Requires scheme and relam . Type: HttpContext - string - string - 'a - HttpFuncResult forbidden Returns 403 Forbidden Type: HttpContext - 'a - HttpFuncResult notFound Returns 404 Not Found Type: HttpContext - 'a - HttpFuncResult methodNotAllowed Returns 405 Method Not Allowed Type: HttpContext - 'a - HttpFuncResult notAcceptable Returns 406 Not Acceptable Type: HttpContext - 'a - HttpFuncResult conflict Returns 409 Conflict Type: HttpContext - 'a - HttpFuncResult gone Returns 410 Gone Type: HttpContext - 'a - HttpFuncResult unuspportedMediaType Returns 415 Unsupported Media Type Type: HttpContext - 'a - HttpFuncResult unprocessableEntity Returns 422 Unprocessable Entity Type: HttpContext - 'a - HttpFuncResult preconditionRequired Returns 428 Precondition Required Type: HttpContext - 'a - HttpFuncResult tooManyRequests Returns 429 Too Many Requests Type: HttpContext - 'a - HttpFuncResult internalError Returns 500 Internal Server Error Type: HttpContext - 'a - HttpFuncResult notImplemented Returns 501 Not Implemented Type: HttpContext - 'a - HttpFuncResult badGateway Returns 502 Bad Gateway Type: HttpContext - 'a - HttpFuncResult serviceUnavailable Returns 503 Service Unavailable Type: HttpContext - 'a - HttpFuncResult gatewayTimeout Returns 504 Gateway Timeout Type: HttpContext - 'a - HttpFuncResult Controller builder Computation expression used to create Saturn controllers - abstraction representing REST-ish endpoint for serving HTML views or returning data. It supports: set of predefined actions that are automatically mapped to the endpoints following standard conventions embedding sub-controllers for modeling one-to-many relationships versioning adding plugs for particular action which in principle provides same mechanism as attributes in ASP.NET MVC applications. defining common error handler for all actions defining not-found action Result of the computation expression is standard Giraffe's HttpHandler which means that it's easily composable with other parts of the ecosytem. Example: let commentController userId = controller { index (fun ctx - (sprintf Comment Index handler for user %i userId ) | Controller.text ctx) add (fun ctx - (sprintf Comment Add handler for user %i userId ) | Controller.text ctx) show (fun (ctx, id) - (sprintf Show comment %s handler for user %i id userId ) | Controller.text ctx) edit (fun (ctx, id) - (sprintf Edit comment %s handler for user %i id userId ) | Controller.text ctx) } let userControllerVersion1 = controller { version 1 subController /comments commentController index (fun ctx - Index handler version 1 | Controller.text ctx) add (fun ctx - Add handler version 1 | Controller.text ctx) show (fun (ctx, id) - (sprintf Show handler version 1 - %i id) | Controller.text ctx) edit (fun (ctx, id) - (sprintf Edit handler version 1 - %i id) | Controller.text ctx) } let userController = controller { subController /comments commentController plug [All] (setHttpHeader user-controller-common 123 ) plug [Index; Show] (setHttpHeader user-controller-specialized 123 ) index (fun ctx - Index handler no version | Controller.text ctx) add (fun ctx - Add handler no version | Controller.text ctx) show (fun (ctx, id) - (sprintf Show handler no version - %i id) | Controller.text ctx) edit (fun (ctx, id) - (sprintf Edit handler no version - %i id) | Controller.text ctx) } index Operation that should render (or return in case of API controllers) list of data Mapped to GET \"/\" endpoint Input: HttpContext - HttpFuncResult show Operation that should render (or return in case of API controllers) single entry of data Mapped to GET \"/:id\" endpoint Input: HttpContext * 'Key - HttpFuncResult add Operation that should render form for adding new item Mapped to GET \"/add\" endpoint Input: HttpContext - HttpFuncResult edit Operation that should render form for editing existing item Mapped to GET \"/:id/edit\" endpoint Input: HttpContext * 'Key - HttpFuncResult create Operation that creates new item Mapped to POST \"/\" and endpoint Input: HttpContext - HttpFuncResult update Operation that updates existing item Mapped to POST \"/:id\" and PATCH \"/:id\" endpoint Input: HttpContext * 'Key - HttpFuncResult delete Operation that deletes existing item Mapped to DELETE \"/:id\" endpoint Input: HttpContext * 'Key - HttpFuncResult delete_all Operation that deletes all items Mapped to DELETE \"/\" endpoint Input: HttpContext - HttpFuncResult not_found_handler Define not-found handler for the controller Input: HttpContext - HttpFuncResult error_handler Define error for the controller Input: HttpContext * Exception - HttpFuncResult subController Adds subcontroller Forward to subcontroller all calls to /:id/:controller_name endpoint Input: string * ('a - HttpHandler) version Define version of controller. Adds checking of x-controller-version header Input: int plug Plugs given HttpHandler for some actions in the controller. Input: Action list * HttpHandler","title":"Controller"},{"location":"api/controller/#controller","text":"","title":"Controller"},{"location":"api/controller/#controller-helpers","text":"Module with high level helper functions that are usually used in controller actions.","title":"Controller helpers"},{"location":"api/controller/#json","text":"Returns to the client content serialized to JSON Type: HttpContext - 'a - HttpFuncResult","title":"json"},{"location":"api/controller/#xml","text":"Returns to the client content serialized to XML. Type: HttpContext - 'a - HttpFuncResult","title":"xml"},{"location":"api/controller/#text","text":"Returns to the client content as string. Type: HttpContext - string - HttpFuncResult","title":"text"},{"location":"api/controller/#render","text":"Returns to the client rendered template. Type: HttpContext - string - HttpFuncResult","title":"render"},{"location":"api/controller/#file","text":"Returns to the client static file. Type: HttpContext - string - HttpFuncResult","title":"file"},{"location":"api/controller/#senddownload","text":"Sends file with given path Type: HttpContext - string - HttpFuncResult","title":"sendDownload"},{"location":"api/controller/#senddownloadbinary","text":"Sends file as binary blob Type: HttpContext - byte [] - HttpFuncResult","title":"sendDownloadBinary"},{"location":"api/controller/#redirect","text":"Sends redirect response Type: HttpContext - string - HttpFuncResult","title":"redirect"},{"location":"api/controller/#getjsona","text":"Gets model from body as JSON. Type: HttpContext - Task 'a","title":"getJson&lt;'a&gt;"},{"location":"api/controller/#getxmla","text":"Gets model from body as XML. Type: HttpContext - Task 'a","title":"getXml&lt;'a&gt;"},{"location":"api/controller/#getforma","text":"Gets model from urelencoded body. Type: HttpContext - Task 'a","title":"getForm&lt;'a&gt;"},{"location":"api/controller/#getquerya","text":"Gets model from query string. Type: HttpContext - Task 'a","title":"getQuery&lt;'a&gt;"},{"location":"api/controller/#getmodela","text":"Get model based on HttpMethod and Content-Type of request. Type: HttpContext - Task 'a","title":"getModel&lt;'a&gt;"},{"location":"api/controller/#loadmodela","text":"Loads model populated by fetchModel pipeline Type: HttpContext - Option 'a","title":"loadModel&lt;'a&gt;"},{"location":"api/controller/#getpath","text":"Gets path of the request - it's relative to current router Type: HttpContext - string","title":"getPath"},{"location":"api/controller/#geturl","text":"Gets url of the request Type: HttpContext - string option","title":"getUrl"},{"location":"api/controller/#getconfiga","text":"Gets configuration Type: HttpContext - 'a","title":"getConfig&lt;'a&gt;"},{"location":"api/controller/#response-helpers","text":"Module with lower level functions for returning certain responses from the action.","title":"Response helpers"},{"location":"api/controller/#continue","text":"Returns 100 Continue Type: HttpContext - HttpFuncResult","title":"continue"},{"location":"api/controller/#switchingproto","text":"Returns 101 Switching Protocols Type: HttpContext - HttpFuncResult","title":"switchingProto"},{"location":"api/controller/#ok","text":"Returns 200 OK Type: HttpContext - 'a - HttpFuncResult","title":"ok"},{"location":"api/controller/#created","text":"Returns 201 Created Type: HttpContext - 'a - HttpFuncResult","title":"created"},{"location":"api/controller/#accepted","text":"Returns 202 Accepted Type: HttpContext - 'a - HttpFuncResult","title":"accepted"},{"location":"api/controller/#badrequest","text":"Returns 400 Bad Request Type: HttpContext - 'a - HttpFuncResult","title":"badRequest"},{"location":"api/controller/#unauthorized","text":"Returns 401 Unauthorized . Requires scheme and relam . Type: HttpContext - string - string - 'a - HttpFuncResult","title":"unauthorized"},{"location":"api/controller/#forbidden","text":"Returns 403 Forbidden Type: HttpContext - 'a - HttpFuncResult","title":"forbidden"},{"location":"api/controller/#notfound","text":"Returns 404 Not Found Type: HttpContext - 'a - HttpFuncResult","title":"notFound"},{"location":"api/controller/#methodnotallowed","text":"Returns 405 Method Not Allowed Type: HttpContext - 'a - HttpFuncResult","title":"methodNotAllowed"},{"location":"api/controller/#notacceptable","text":"Returns 406 Not Acceptable Type: HttpContext - 'a - HttpFuncResult","title":"notAcceptable"},{"location":"api/controller/#conflict","text":"Returns 409 Conflict Type: HttpContext - 'a - HttpFuncResult","title":"conflict"},{"location":"api/controller/#gone","text":"Returns 410 Gone Type: HttpContext - 'a - HttpFuncResult","title":"gone"},{"location":"api/controller/#unuspportedmediatype","text":"Returns 415 Unsupported Media Type Type: HttpContext - 'a - HttpFuncResult","title":"unuspportedMediaType"},{"location":"api/controller/#unprocessableentity","text":"Returns 422 Unprocessable Entity Type: HttpContext - 'a - HttpFuncResult","title":"unprocessableEntity"},{"location":"api/controller/#preconditionrequired","text":"Returns 428 Precondition Required Type: HttpContext - 'a - HttpFuncResult","title":"preconditionRequired"},{"location":"api/controller/#toomanyrequests","text":"Returns 429 Too Many Requests Type: HttpContext - 'a - HttpFuncResult","title":"tooManyRequests"},{"location":"api/controller/#internalerror","text":"Returns 500 Internal Server Error Type: HttpContext - 'a - HttpFuncResult","title":"internalError"},{"location":"api/controller/#notimplemented","text":"Returns 501 Not Implemented Type: HttpContext - 'a - HttpFuncResult","title":"notImplemented"},{"location":"api/controller/#badgateway","text":"Returns 502 Bad Gateway Type: HttpContext - 'a - HttpFuncResult","title":"badGateway"},{"location":"api/controller/#serviceunavailable","text":"Returns 503 Service Unavailable Type: HttpContext - 'a - HttpFuncResult","title":"serviceUnavailable"},{"location":"api/controller/#gatewaytimeout","text":"Returns 504 Gateway Timeout Type: HttpContext - 'a - HttpFuncResult","title":"gatewayTimeout"},{"location":"api/controller/#controller-builder","text":"Computation expression used to create Saturn controllers - abstraction representing REST-ish endpoint for serving HTML views or returning data. It supports: set of predefined actions that are automatically mapped to the endpoints following standard conventions embedding sub-controllers for modeling one-to-many relationships versioning adding plugs for particular action which in principle provides same mechanism as attributes in ASP.NET MVC applications. defining common error handler for all actions defining not-found action Result of the computation expression is standard Giraffe's HttpHandler which means that it's easily composable with other parts of the ecosytem. Example: let commentController userId = controller { index (fun ctx - (sprintf Comment Index handler for user %i userId ) | Controller.text ctx) add (fun ctx - (sprintf Comment Add handler for user %i userId ) | Controller.text ctx) show (fun (ctx, id) - (sprintf Show comment %s handler for user %i id userId ) | Controller.text ctx) edit (fun (ctx, id) - (sprintf Edit comment %s handler for user %i id userId ) | Controller.text ctx) } let userControllerVersion1 = controller { version 1 subController /comments commentController index (fun ctx - Index handler version 1 | Controller.text ctx) add (fun ctx - Add handler version 1 | Controller.text ctx) show (fun (ctx, id) - (sprintf Show handler version 1 - %i id) | Controller.text ctx) edit (fun (ctx, id) - (sprintf Edit handler version 1 - %i id) | Controller.text ctx) } let userController = controller { subController /comments commentController plug [All] (setHttpHeader user-controller-common 123 ) plug [Index; Show] (setHttpHeader user-controller-specialized 123 ) index (fun ctx - Index handler no version | Controller.text ctx) add (fun ctx - Add handler no version | Controller.text ctx) show (fun (ctx, id) - (sprintf Show handler no version - %i id) | Controller.text ctx) edit (fun (ctx, id) - (sprintf Edit handler no version - %i id) | Controller.text ctx) }","title":"Controller builder"},{"location":"api/controller/#index","text":"Operation that should render (or return in case of API controllers) list of data Mapped to GET \"/\" endpoint Input: HttpContext - HttpFuncResult","title":"index"},{"location":"api/controller/#show","text":"Operation that should render (or return in case of API controllers) single entry of data Mapped to GET \"/:id\" endpoint Input: HttpContext * 'Key - HttpFuncResult","title":"show"},{"location":"api/controller/#add","text":"Operation that should render form for adding new item Mapped to GET \"/add\" endpoint Input: HttpContext - HttpFuncResult","title":"add"},{"location":"api/controller/#edit","text":"Operation that should render form for editing existing item Mapped to GET \"/:id/edit\" endpoint Input: HttpContext * 'Key - HttpFuncResult","title":"edit"},{"location":"api/controller/#create","text":"Operation that creates new item Mapped to POST \"/\" and endpoint Input: HttpContext - HttpFuncResult","title":"create"},{"location":"api/controller/#update","text":"Operation that updates existing item Mapped to POST \"/:id\" and PATCH \"/:id\" endpoint Input: HttpContext * 'Key - HttpFuncResult","title":"update"},{"location":"api/controller/#delete","text":"Operation that deletes existing item Mapped to DELETE \"/:id\" endpoint Input: HttpContext * 'Key - HttpFuncResult","title":"delete"},{"location":"api/controller/#delete_all","text":"Operation that deletes all items Mapped to DELETE \"/\" endpoint Input: HttpContext - HttpFuncResult","title":"delete_all"},{"location":"api/controller/#not_found_handler","text":"Define not-found handler for the controller Input: HttpContext - HttpFuncResult","title":"not_found_handler"},{"location":"api/controller/#error_handler","text":"Define error for the controller Input: HttpContext * Exception - HttpFuncResult","title":"error_handler"},{"location":"api/controller/#subcontroller","text":"Adds subcontroller Forward to subcontroller all calls to /:id/:controller_name endpoint Input: string * ('a - HttpHandler)","title":"subController"},{"location":"api/controller/#version","text":"Define version of controller. Adds checking of x-controller-version header Input: int","title":"version"},{"location":"api/controller/#plug","text":"Plugs given HttpHandler for some actions in the controller. Input: Action list * HttpHandler","title":"plug"},{"location":"api/pipeline/","text":"Pipeline Pipeline builder Computation expression used to combine HttpHandlers in declarative manner. The result of the computation expression is a standard Giraffe HttpHandler which means that it's easily composable with other parts of the Giraffe ecosystem. Example: let headerPipe = pipeline { set_header myCustomHeader abcd set_header myCustomHeader2 zxcv } let endpointPipe = pipeline { plug fetchSession plug head plug requestId } plug Enables adding any additional HttpHandler to the pipeline Input: HttpHandler must_accept Filters a request by the Accept HTTP header. You can use it to check if a client accepts a certain mime type before returning a response. Input: string challenge Challenges an authentication with a specified authentication scheme Input: string sign_off Signs off the currently logged in user with a specified authentication scheme. Input: string requires_auth_policy Validates if a user satisfies policy requirement, if not then the handler will execute the authFailedHandler function. Input: (ClaimsPrincipal - bool) - HttpHandler requires_authentication Validates if a user is authenticated/logged in. If the user is not authenticated then the handler will execute the authFailedHandler function. Input: HttpHandler requires_role Validates if an authenticated user is in a specified role. If the user fails to be in the required role then the handler will execute the authFailedHandler function. Input: string - HttpHandler requires_role_of Validates if an authenticated user is in one of the supplied roles. If the user fails to be in one of the required roles then the handler will execute the authFailedHandler function. Input: string list- HttpHandler clear_response Tries to clear the current response. This can be useful inside an error handler to reset the response before writing an error message to the body of the HTTP response object. set_status_code Changes the status code of the HttpResponse . Input: int set_header Sets or modifies a HTTP header of the HttpResponse . Input: string - 'a set_body Sets or modifies the body of the HttpResponse . This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. Input: byte[] text Sets or modifies the body of the HttpResponse by sending a plain text value to the client. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. It also sets the Content-Type HTTP header to text/plain . Input: string json Sets or modifies the body of the HttpResponse by sending a JSON serialized object to the client. It uses JSON serializer configured by Giraffe. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. It also sets the Content-Type HTTP header to application/json . Input: 'a xml Sets or modifies the body of the HttpResponse by sending an XML serialized object to the client. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. It also sets the Content-Type HTTP header to application/xml . Input: 'a negotiate Sets or modifies the body of the HttpResponse by inspecting the Accept header of the HTTP request and deciding if the response should be sent in JSON or XML or plain text. If the client is indifferent then the default response will be sent in JSON. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. Input: 'a negotiate_with Sets or modifies the body of the HttpResponse by inspecting the Accept header of the HTTP request and deciding in what mimeType the response should be sent. A dictionary of type IDictionary string, obj - HttpHandler is used to determine which obj - HttpHandler function should be used to convert an object into a HttpHandler for a given mime type. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. Input: (IDictionary string, obj - HttpHandler ) - 'a html Sets or modifies the body of the HttpResponse with the contents of a single string variable. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. Sets the HTTP header Content-Type to text/html Input: string html_file Sets or modifies the body of the HttpResponse with the contents of a physical html file. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. This http handler takes a rooted path of a html file or a path which is relative to the ContentRootPath as the input parameter and sets the HTTP header Content-Type to text/html Input: string render_html It is a more functional way of generating HTML by composing HTML elements in F# to generate a rich Model-View output. Input: XmlNode redirect_to Uses a 302 or 301 (when permanent) HTTP response code to redirect the client to the specified location. It takes in two parameters, a boolean flag denoting whether the redirect should be permanent or not and the location to redirect to. Input: bool - string route_ports If your web server is listening to multiple ports then you can use the routePorts HttpHandler to easily filter incoming requests based on their port by providing a list of port number and HttpHandler ( (int * HttpHandler) list ). Input: (int - HttpHandler) list use_warbler If your route is not returning a static response, then you should wrap your function with a warbler. Functions in F# are eagerly evaluated and the warbler will help to evaluate the function every time the route is hit. Input: HttpHandler Pipeline Helpers Module containing a couple of more advanced HttpHandlers commonly used in Saturn applications acceptJson Accepts ContentType application/json acceptXml Accepts ContentType application/xml acceptHtml Accepts ContentType text/html acceptMultipart Accepts ContentType multipart/form-data putSecureBrowserHeaders Adds headers that improve browser security. It sets the following headers: x-frame-options - set to SAMEORIGIN to avoid clickjacking through iframes unless in the same origin x-content-type-options - set to nosniff. This requires script and style tags to be sent with proper content type x-xss-protection - set to \"1; mode=block\" to improve XSS protection on both Chrome and IE x-download-options - set to noopen to instruct the browser not to open a download directly in the browser, to avoid HTML files rendering inline and accessing the security context of the application (like critical domain cookies) x-permitted-cross-domain-policies - set to none to restrict Adobe Flash Player\u2019s access to data enableCors Enables CORS protection using provided config. Use CORS.defaultCORSConfig for default configuration. Input: CORSConfig fetchSession Fetches session from session provider. If it won't be called session will be synchronusly fetched on first usage. fetchModel Tries to get the model from the request and puts model into Items.RequestModel . If it won't be called content can be fetched using Context.Controller helpers. It won't crash the pipelines if fetching failed. It optionally takes custom culture name as arguments. Input: string option head Convert HEAD requests to GET requests. requestId Pipeline for generating a unique request id for each request. A generated request id will in the format uq8hs30oafhj5vve8ji5pmp7mtopc08f . If a request id already exists as the x-request-id HTTP request header, then that value will be used assuming it is between 20 and 200 characters. If it is not, a new request id will be generated. Request id is put into x-request-id HTTP header and into Items directory of HttpContext with RequestId key. requireHeader Requires given value for given request header Input: string - string","title":"Pipeline"},{"location":"api/pipeline/#pipeline","text":"","title":"Pipeline"},{"location":"api/pipeline/#pipeline-builder","text":"Computation expression used to combine HttpHandlers in declarative manner. The result of the computation expression is a standard Giraffe HttpHandler which means that it's easily composable with other parts of the Giraffe ecosystem. Example: let headerPipe = pipeline { set_header myCustomHeader abcd set_header myCustomHeader2 zxcv } let endpointPipe = pipeline { plug fetchSession plug head plug requestId }","title":"Pipeline builder"},{"location":"api/pipeline/#plug","text":"Enables adding any additional HttpHandler to the pipeline Input: HttpHandler","title":"plug"},{"location":"api/pipeline/#must_accept","text":"Filters a request by the Accept HTTP header. You can use it to check if a client accepts a certain mime type before returning a response. Input: string","title":"must_accept"},{"location":"api/pipeline/#challenge","text":"Challenges an authentication with a specified authentication scheme Input: string","title":"challenge"},{"location":"api/pipeline/#sign_off","text":"Signs off the currently logged in user with a specified authentication scheme. Input: string","title":"sign_off"},{"location":"api/pipeline/#requires_auth_policy","text":"Validates if a user satisfies policy requirement, if not then the handler will execute the authFailedHandler function. Input: (ClaimsPrincipal - bool) - HttpHandler","title":"requires_auth_policy"},{"location":"api/pipeline/#requires_authentication","text":"Validates if a user is authenticated/logged in. If the user is not authenticated then the handler will execute the authFailedHandler function. Input: HttpHandler","title":"requires_authentication"},{"location":"api/pipeline/#requires_role","text":"Validates if an authenticated user is in a specified role. If the user fails to be in the required role then the handler will execute the authFailedHandler function. Input: string - HttpHandler","title":"requires_role"},{"location":"api/pipeline/#requires_role_of","text":"Validates if an authenticated user is in one of the supplied roles. If the user fails to be in one of the required roles then the handler will execute the authFailedHandler function. Input: string list- HttpHandler","title":"requires_role_of"},{"location":"api/pipeline/#clear_response","text":"Tries to clear the current response. This can be useful inside an error handler to reset the response before writing an error message to the body of the HTTP response object.","title":"clear_response"},{"location":"api/pipeline/#set_status_code","text":"Changes the status code of the HttpResponse . Input: int","title":"set_status_code"},{"location":"api/pipeline/#set_header","text":"Sets or modifies a HTTP header of the HttpResponse . Input: string - 'a","title":"set_header"},{"location":"api/pipeline/#set_body","text":"Sets or modifies the body of the HttpResponse . This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. Input: byte[]","title":"set_body"},{"location":"api/pipeline/#text","text":"Sets or modifies the body of the HttpResponse by sending a plain text value to the client. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. It also sets the Content-Type HTTP header to text/plain . Input: string","title":"text"},{"location":"api/pipeline/#json","text":"Sets or modifies the body of the HttpResponse by sending a JSON serialized object to the client. It uses JSON serializer configured by Giraffe. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. It also sets the Content-Type HTTP header to application/json . Input: 'a","title":"json"},{"location":"api/pipeline/#xml","text":"Sets or modifies the body of the HttpResponse by sending an XML serialized object to the client. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. It also sets the Content-Type HTTP header to application/xml . Input: 'a","title":"xml"},{"location":"api/pipeline/#negotiate","text":"Sets or modifies the body of the HttpResponse by inspecting the Accept header of the HTTP request and deciding if the response should be sent in JSON or XML or plain text. If the client is indifferent then the default response will be sent in JSON. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. Input: 'a","title":"negotiate"},{"location":"api/pipeline/#negotiate_with","text":"Sets or modifies the body of the HttpResponse by inspecting the Accept header of the HTTP request and deciding in what mimeType the response should be sent. A dictionary of type IDictionary string, obj - HttpHandler is used to determine which obj - HttpHandler function should be used to convert an object into a HttpHandler for a given mime type. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. Input: (IDictionary string, obj - HttpHandler ) - 'a","title":"negotiate_with"},{"location":"api/pipeline/#html","text":"Sets or modifies the body of the HttpResponse with the contents of a single string variable. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. Sets the HTTP header Content-Type to text/html Input: string","title":"html"},{"location":"api/pipeline/#html_file","text":"Sets or modifies the body of the HttpResponse with the contents of a physical html file. This http handler triggers a response to the client and other http handlers will not be able to modify the HTTP headers afterwards any more. This http handler takes a rooted path of a html file or a path which is relative to the ContentRootPath as the input parameter and sets the HTTP header Content-Type to text/html Input: string","title":"html_file"},{"location":"api/pipeline/#render_html","text":"It is a more functional way of generating HTML by composing HTML elements in F# to generate a rich Model-View output. Input: XmlNode","title":"render_html"},{"location":"api/pipeline/#redirect_to","text":"Uses a 302 or 301 (when permanent) HTTP response code to redirect the client to the specified location. It takes in two parameters, a boolean flag denoting whether the redirect should be permanent or not and the location to redirect to. Input: bool - string","title":"redirect_to"},{"location":"api/pipeline/#route_ports","text":"If your web server is listening to multiple ports then you can use the routePorts HttpHandler to easily filter incoming requests based on their port by providing a list of port number and HttpHandler ( (int * HttpHandler) list ). Input: (int - HttpHandler) list","title":"route_ports"},{"location":"api/pipeline/#use_warbler","text":"If your route is not returning a static response, then you should wrap your function with a warbler. Functions in F# are eagerly evaluated and the warbler will help to evaluate the function every time the route is hit. Input: HttpHandler","title":"use_warbler"},{"location":"api/pipeline/#pipeline-helpers","text":"Module containing a couple of more advanced HttpHandlers commonly used in Saturn applications","title":"Pipeline Helpers"},{"location":"api/pipeline/#acceptjson","text":"Accepts ContentType application/json","title":"acceptJson"},{"location":"api/pipeline/#acceptxml","text":"Accepts ContentType application/xml","title":"acceptXml"},{"location":"api/pipeline/#accepthtml","text":"Accepts ContentType text/html","title":"acceptHtml"},{"location":"api/pipeline/#acceptmultipart","text":"Accepts ContentType multipart/form-data","title":"acceptMultipart"},{"location":"api/pipeline/#putsecurebrowserheaders","text":"Adds headers that improve browser security. It sets the following headers: x-frame-options - set to SAMEORIGIN to avoid clickjacking through iframes unless in the same origin x-content-type-options - set to nosniff. This requires script and style tags to be sent with proper content type x-xss-protection - set to \"1; mode=block\" to improve XSS protection on both Chrome and IE x-download-options - set to noopen to instruct the browser not to open a download directly in the browser, to avoid HTML files rendering inline and accessing the security context of the application (like critical domain cookies) x-permitted-cross-domain-policies - set to none to restrict Adobe Flash Player\u2019s access to data","title":"putSecureBrowserHeaders"},{"location":"api/pipeline/#enablecors","text":"Enables CORS protection using provided config. Use CORS.defaultCORSConfig for default configuration. Input: CORSConfig","title":"enableCors"},{"location":"api/pipeline/#fetchsession","text":"Fetches session from session provider. If it won't be called session will be synchronusly fetched on first usage.","title":"fetchSession"},{"location":"api/pipeline/#fetchmodel","text":"Tries to get the model from the request and puts model into Items.RequestModel . If it won't be called content can be fetched using Context.Controller helpers. It won't crash the pipelines if fetching failed. It optionally takes custom culture name as arguments. Input: string option","title":"fetchModel"},{"location":"api/pipeline/#head","text":"Convert HEAD requests to GET requests.","title":"head"},{"location":"api/pipeline/#requestid","text":"Pipeline for generating a unique request id for each request. A generated request id will in the format uq8hs30oafhj5vve8ji5pmp7mtopc08f . If a request id already exists as the x-request-id HTTP request header, then that value will be used assuming it is between 20 and 200 characters. If it is not, a new request id will be generated. Request id is put into x-request-id HTTP header and into Items directory of HttpContext with RequestId key.","title":"requestId"},{"location":"api/pipeline/#requireheader","text":"Requires given value for given request header Input: string - string","title":"requireHeader"},{"location":"api/router/","text":"Router Router builder Computation expression used to create routing, combining HttpHandlers , pipelines and controllers together. Result of the computation expression is standard Giraffe's HttpHandler which means that it's easily composable with other parts of the ecosytem. Example: let topRouter = router { pipe_through headerPipe not_found_handler (text 404 ) get / helloWorld get /a helloWorld2 getf /name/%s helloWorldName getf /name/%s/%i helloWorldNameAge //routers can be defined inline to simulate `subRoute` combinator forward /other (router { pipe_through otherHeaderPipe not_found_handler (text Other 404 ) get / otherHelloWorld get /a otherHelloWorld2 }) // or can be defined separatly and used as HttpHandler forward /api apiRouter // same with controllers forward /users userController } get Adds handler for GET request. Input: : string * HttpHandler getf Adds handler for GET request using formatter. Input: : PrintfFormat _,_,_,_'f * ('f - HttpHandler) post Adds handler for POST request. Input: : string * HttpHandler postf Adds handler for POST request using formatter. Input: : PrintfFormat _,_,_,_'f * ('f - HttpHandler) put Adds handler for PUT request. Input: : string * HttpHandler putf Adds handler for PUT request using formatter. Input: : PrintfFormat _,_,_,_'f * ('f - HttpHandler) delete Adds handler for DELETE request. Input: : string * HttpHandler deletef Adds handler for DELETE request using formatter. Input: : PrintfFormat _,_,_,_'f * ('f - HttpHandler) patch Adds handler for PATCH request. Input: : string * HttpHandler patchf Adds handler for PATCH request using formatter. Input: : PrintfFormat _,_,_,_'f * ('f - HttpHandler) forward Forwards calls to different router . Modifies the HttpRequest.Path to allow subrouting. Input: : string * HttpHandler pipe_through Adds pipeline to the list of pipelines that will be used for every request Input: : HttpHandler not_found_handler Adds not-found handler for current router Input: : HttpHandler","title":"Router"},{"location":"api/router/#router","text":"","title":"Router"},{"location":"api/router/#router-builder","text":"Computation expression used to create routing, combining HttpHandlers , pipelines and controllers together. Result of the computation expression is standard Giraffe's HttpHandler which means that it's easily composable with other parts of the ecosytem. Example: let topRouter = router { pipe_through headerPipe not_found_handler (text 404 ) get / helloWorld get /a helloWorld2 getf /name/%s helloWorldName getf /name/%s/%i helloWorldNameAge //routers can be defined inline to simulate `subRoute` combinator forward /other (router { pipe_through otherHeaderPipe not_found_handler (text Other 404 ) get / otherHelloWorld get /a otherHelloWorld2 }) // or can be defined separatly and used as HttpHandler forward /api apiRouter // same with controllers forward /users userController }","title":"Router builder"},{"location":"api/router/#get","text":"Adds handler for GET request. Input: : string * HttpHandler","title":"get"},{"location":"api/router/#getf","text":"Adds handler for GET request using formatter. Input: : PrintfFormat _,_,_,_'f * ('f - HttpHandler)","title":"getf"},{"location":"api/router/#post","text":"Adds handler for POST request. Input: : string * HttpHandler","title":"post"},{"location":"api/router/#postf","text":"Adds handler for POST request using formatter. Input: : PrintfFormat _,_,_,_'f * ('f - HttpHandler)","title":"postf"},{"location":"api/router/#put","text":"Adds handler for PUT request. Input: : string * HttpHandler","title":"put"},{"location":"api/router/#putf","text":"Adds handler for PUT request using formatter. Input: : PrintfFormat _,_,_,_'f * ('f - HttpHandler)","title":"putf"},{"location":"api/router/#delete","text":"Adds handler for DELETE request. Input: : string * HttpHandler","title":"delete"},{"location":"api/router/#deletef","text":"Adds handler for DELETE request using formatter. Input: : PrintfFormat _,_,_,_'f * ('f - HttpHandler)","title":"deletef"},{"location":"api/router/#patch","text":"Adds handler for PATCH request. Input: : string * HttpHandler","title":"patch"},{"location":"api/router/#patchf","text":"Adds handler for PATCH request using formatter. Input: : PrintfFormat _,_,_,_'f * ('f - HttpHandler)","title":"patchf"},{"location":"api/router/#forward","text":"Forwards calls to different router . Modifies the HttpRequest.Path to allow subrouting. Input: : string * HttpHandler","title":"forward"},{"location":"api/router/#pipe_through","text":"Adds pipeline to the list of pipelines that will be used for every request Input: : HttpHandler","title":"pipe_through"},{"location":"api/router/#not_found_handler","text":"Adds not-found handler for current router Input: : HttpHandler","title":"not_found_handler"},{"location":"guides/adding-pages/","text":"Adding Pages Using the same project from the how to start guide . Let's add two pages to it. One hello page and a page that can get your name from the URL. Creating the View To begin, create a Hello folder inside the src/SaturnSample folder. Inside the folder, create a new file called \"HelloViews.fs\", this file will contain the functions to create the page. Insert the following in the file: namespace Hello open Giraffe.GiraffeViewEngine open Saturn module Views = let index = div [] [ h2 [] [rawText Hello from Saturn! ] ] One of the dependencies required is Giraffe View Engine . This will allow your project to define html within your function. The index function will result in the following html code. div h2 Hello from Saturn! /h2 /div Creating the controller Create a HelloController.fs file inside the Hello folder. The index function tells us what the html will be but we still need to tell Saturn to return it as an html page. We also need to tell Saturn where the page is. Insert the following into the file. namespace Hello open Saturn open Giraffe.ResponseWriters module Controller = let indexAction = htmlView (Views.index) let helloView = router { get / indexAction } The indexAction tells Saturn to create an html page using the index function inside \"HelloViews.fs\" helloView lets Saturn know that the page is located at the root. Adding it to Router.fs After setting up the route. You need to update the project with the new route. Inside \"Router.fs\", add the following to the inside of the browserRouter function: forward /hello HelloView This means that when we navigate to http://localhost:8085/hello , the helloView function will determine what page to load there. Looking inside the helloView function, we said that indexAction is called at the root. In conclusion, the page will be located at http://localhost:8085/hello/ . (Note the \"/\" at the end) Now run the program and go to http://localhost:8085/hello/ and you will see a page saying \"Hello from Saturn!\" Adding the 2 new files into SaturnSample.fsproj as below ItemGroup Compile Include=\"Database.fs\" / Compile Include=\"Config.fs\" / Compile Include=\"Hello\\HelloViews.fs\" / Compile Include=\"Hello\\HelloController.fs\" / Sending parameter to your page What if you want the page to display your name? One way to retrieve your name is to get it from the route. So when you go to http://localhost:8085/hello/{yourname} with {yourname} being your actual name, it will grab your name which can then be used to display it on the page. To begin, add a new view in your HelloViews.fs let index2 (name : string) = div [] [ h2 [] [rawText ( Hello + name + ! )] ] This function requires passing in the name to be displayed. The name will be retrieved from the route. Add the following to the HelloController.fs file below the helloView handler: let index2Action name= htmlView (Hello.Views.index2 name) Now to set up the route. Add the following to the HelloView handler: getf /%s index2Action \"%s\" is a format string. This lets Saturn know to save whatever you type in that spot. Since we want to save a name, we want to save it as a string so we use %s . There are other format strings for different types. Format Char Type %b bool %c char %s string %i int %d int64 %f float / double %O Guid Now run the program and go to http://localhost:8085/hello/{yourname} and replace {yourname} with your name to see a page that will greet you.","title":"Adding Pages"},{"location":"guides/adding-pages/#adding-pages","text":"Using the same project from the how to start guide . Let's add two pages to it. One hello page and a page that can get your name from the URL.","title":"Adding Pages"},{"location":"guides/adding-pages/#creating-the-view","text":"To begin, create a Hello folder inside the src/SaturnSample folder. Inside the folder, create a new file called \"HelloViews.fs\", this file will contain the functions to create the page. Insert the following in the file: namespace Hello open Giraffe.GiraffeViewEngine open Saturn module Views = let index = div [] [ h2 [] [rawText Hello from Saturn! ] ] One of the dependencies required is Giraffe View Engine . This will allow your project to define html within your function. The index function will result in the following html code. div h2 Hello from Saturn! /h2 /div","title":"Creating the View"},{"location":"guides/adding-pages/#creating-the-controller","text":"Create a HelloController.fs file inside the Hello folder. The index function tells us what the html will be but we still need to tell Saturn to return it as an html page. We also need to tell Saturn where the page is. Insert the following into the file. namespace Hello open Saturn open Giraffe.ResponseWriters module Controller = let indexAction = htmlView (Views.index) let helloView = router { get / indexAction } The indexAction tells Saturn to create an html page using the index function inside \"HelloViews.fs\" helloView lets Saturn know that the page is located at the root.","title":"Creating the controller"},{"location":"guides/adding-pages/#adding-it-to-routerfs","text":"After setting up the route. You need to update the project with the new route. Inside \"Router.fs\", add the following to the inside of the browserRouter function: forward /hello HelloView This means that when we navigate to http://localhost:8085/hello , the helloView function will determine what page to load there. Looking inside the helloView function, we said that indexAction is called at the root. In conclusion, the page will be located at http://localhost:8085/hello/ . (Note the \"/\" at the end) Now run the program and go to http://localhost:8085/hello/ and you will see a page saying \"Hello from Saturn!\"","title":"Adding it to Router.fs"},{"location":"guides/adding-pages/#adding-the-2-new-files-into-saturnsamplefsproj-as-below","text":"ItemGroup Compile Include=\"Database.fs\" / Compile Include=\"Config.fs\" / Compile Include=\"Hello\\HelloViews.fs\" / Compile Include=\"Hello\\HelloController.fs\" /","title":"Adding the 2 new files into SaturnSample.fsproj as below"},{"location":"guides/adding-pages/#sending-parameter-to-your-page","text":"What if you want the page to display your name? One way to retrieve your name is to get it from the route. So when you go to http://localhost:8085/hello/{yourname} with {yourname} being your actual name, it will grab your name which can then be used to display it on the page. To begin, add a new view in your HelloViews.fs let index2 (name : string) = div [] [ h2 [] [rawText ( Hello + name + ! )] ] This function requires passing in the name to be displayed. The name will be retrieved from the route. Add the following to the HelloController.fs file below the helloView handler: let index2Action name= htmlView (Hello.Views.index2 name) Now to set up the route. Add the following to the HelloView handler: getf /%s index2Action \"%s\" is a format string. This lets Saturn know to save whatever you type in that spot. Since we want to save a name, we want to save it as a string so we use %s . There are other format strings for different types. Format Char Type %b bool %c char %s string %i int %d int64 %f float / double %O Guid Now run the program and go to http://localhost:8085/hello/{yourname} and replace {yourname} with your name to see a page that will greet you.","title":"Sending parameter to your page"},{"location":"guides/directory-structure/","text":"Directory Structure After creating a new Saturn project, let's take a deeper look into what files are created. \u251c\u2500\u2500 .fake \u251c\u2500\u2500 .paket \u251c\u2500\u2500 .vs \u251c\u2500\u2500 .packages \u251c\u2500\u2500 paket-files \u251c\u2500\u2500 src | \u251c\u2500\u2500 Migrations | \u2514\u2500\u2500 SaturnSample \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 build.cmd \u251c\u2500\u2500 build.fsx \u251c\u2500\u2500 build.sh \u251c\u2500\u2500 global.json \u251c\u2500\u2500 paket.dependencies \u251c\u2500\u2500 paket.lock \u2514\u2500\u2500 SaturnSample.sln At this level most of it is basic configuration files to help with running Saturn. From looking at the .paket , paket-files , paket.dependencies , paket.lock folders and files, you can see that by default Saturn uses paket to handle package management. You won't be working with these files directly but rather through the command line tools instead. Saturn also uses FAKE to build the project. You can see how it is set up by looking at the .fake folder and the build.cmd , build.fsx , build.sh files. Saturn also provides a .gitignore file that prevents some folders from being tracked by git when they don't need to. Lastly, there is the SaturnSample.sln solution file so you can open the project in an IDE like Visual Sudio and a global.json file to configure the solution file. Most of the work you will do in this project however, will be in src/SaturnSample , which looks like the following when expanded: \u251c\u2500\u2500 bin \u251c\u2500\u2500 Books | \u251c\u2500\u2500 BooksController.fs | \u251c\u2500\u2500 BooksModel.fs | \u251c\u2500\u2500 BooksRepository.fs | \u2514\u2500\u2500 BooksView.fs \u251c\u2500\u2500 obj \u251c\u2500\u2500 static | \u251c\u2500\u2500 app.css | \u2514\u2500\u2500 app.js \u251c\u2500\u2500 Templates | \u251c\u2500\u2500 App.fs | \u251c\u2500\u2500 Index.fs | \u251c\u2500\u2500 InternalError.fs | \u2514\u2500\u2500 NotFound.fs \u251c\u2500\u2500 Config.fs \u251c\u2500\u2500 Database.fs \u251c\u2500\u2500 database.sqlite \u251c\u2500\u2500 paket.references \u251c\u2500\u2500 Program.fs \u251c\u2500\u2500 Router.fs \u2514\u2500\u2500 SaturnSample.fsproj bin and obj folders store the compiled version of the program after you build the project. The convention for Saturn is that the model and everything associated with it are inside one folder. Everything is also named with the plural form of the model so \"Books\" instead of \"Book\". Your static files like css, js, and images should be inside the static folder. Config.fs contains a Config record that stores settings that you can use inside your application. By default, the record only contains the connectionString field. Database.fs contains functions to execute sql queries within the program through Dapper . If you did not run dotnet saturn migration as in the how to start guide , you might not see database.sqlite but that is the database file that your Saturn project is using to store data. paket.references shows the packages that your project is using. Program.fs handles intializing the program and loading up various settings. Router.fs is where you will set the route of the site and what page to load. Lastly, SaturnSample.fsproj is the project file itself.","title":"Directory Structure"},{"location":"guides/directory-structure/#directory-structure","text":"After creating a new Saturn project, let's take a deeper look into what files are created. \u251c\u2500\u2500 .fake \u251c\u2500\u2500 .paket \u251c\u2500\u2500 .vs \u251c\u2500\u2500 .packages \u251c\u2500\u2500 paket-files \u251c\u2500\u2500 src | \u251c\u2500\u2500 Migrations | \u2514\u2500\u2500 SaturnSample \u251c\u2500\u2500 .gitignore \u251c\u2500\u2500 build.cmd \u251c\u2500\u2500 build.fsx \u251c\u2500\u2500 build.sh \u251c\u2500\u2500 global.json \u251c\u2500\u2500 paket.dependencies \u251c\u2500\u2500 paket.lock \u2514\u2500\u2500 SaturnSample.sln At this level most of it is basic configuration files to help with running Saturn. From looking at the .paket , paket-files , paket.dependencies , paket.lock folders and files, you can see that by default Saturn uses paket to handle package management. You won't be working with these files directly but rather through the command line tools instead. Saturn also uses FAKE to build the project. You can see how it is set up by looking at the .fake folder and the build.cmd , build.fsx , build.sh files. Saturn also provides a .gitignore file that prevents some folders from being tracked by git when they don't need to. Lastly, there is the SaturnSample.sln solution file so you can open the project in an IDE like Visual Sudio and a global.json file to configure the solution file. Most of the work you will do in this project however, will be in src/SaturnSample , which looks like the following when expanded: \u251c\u2500\u2500 bin \u251c\u2500\u2500 Books | \u251c\u2500\u2500 BooksController.fs | \u251c\u2500\u2500 BooksModel.fs | \u251c\u2500\u2500 BooksRepository.fs | \u2514\u2500\u2500 BooksView.fs \u251c\u2500\u2500 obj \u251c\u2500\u2500 static | \u251c\u2500\u2500 app.css | \u2514\u2500\u2500 app.js \u251c\u2500\u2500 Templates | \u251c\u2500\u2500 App.fs | \u251c\u2500\u2500 Index.fs | \u251c\u2500\u2500 InternalError.fs | \u2514\u2500\u2500 NotFound.fs \u251c\u2500\u2500 Config.fs \u251c\u2500\u2500 Database.fs \u251c\u2500\u2500 database.sqlite \u251c\u2500\u2500 paket.references \u251c\u2500\u2500 Program.fs \u251c\u2500\u2500 Router.fs \u2514\u2500\u2500 SaturnSample.fsproj bin and obj folders store the compiled version of the program after you build the project. The convention for Saturn is that the model and everything associated with it are inside one folder. Everything is also named with the plural form of the model so \"Books\" instead of \"Book\". Your static files like css, js, and images should be inside the static folder. Config.fs contains a Config record that stores settings that you can use inside your application. By default, the record only contains the connectionString field. Database.fs contains functions to execute sql queries within the program through Dapper . If you did not run dotnet saturn migration as in the how to start guide , you might not see database.sqlite but that is the database file that your Saturn project is using to store data. paket.references shows the packages that your project is using. Program.fs handles intializing the program and loading up various settings. Router.fs is where you will set the route of the site and what page to load. Lastly, SaturnSample.fsproj is the project file itself.","title":"Directory Structure"},{"location":"guides/how-to-start/","text":"How to start in 60 seconds Install dotnet template with dotnet new -i Saturn.Template Create new folder and move into it - mkdir SaturnSample cd SaturnSample Create new Saturn application - dotnet new saturn -lang F# Run build process to ensure everything was scaffolded correctly and restore dependencies - build.cmd / build.sh Go into subdirectory with server application - cd src/SaturnSample Create new controller with dotnet saturn gen Book Books id:string title:string author:string Run migrations that will create database and Books table (as for now, generator is using only SQLite DB) - dotnet saturn migration Open folder in favourite editor (VSCode) and insert suggested line ( forward \"/books\" Books.Controller.resource ) into browserRouter in Router.fs file Start application by running build.cmd Run from the root of solution. This will start application in watch mode (automatic recompilation on changes) and open browser on http://localhost:8085 which should display index page. Go to http://localhost:8085/books to see generated view. All buttons should be working, you can add new entries, remove or edit old ones.","title":"How to start in 60 seconds"},{"location":"guides/how-to-start/#how-to-start-in-60-seconds","text":"Install dotnet template with dotnet new -i Saturn.Template Create new folder and move into it - mkdir SaturnSample cd SaturnSample Create new Saturn application - dotnet new saturn -lang F# Run build process to ensure everything was scaffolded correctly and restore dependencies - build.cmd / build.sh Go into subdirectory with server application - cd src/SaturnSample Create new controller with dotnet saturn gen Book Books id:string title:string author:string Run migrations that will create database and Books table (as for now, generator is using only SQLite DB) - dotnet saturn migration Open folder in favourite editor (VSCode) and insert suggested line ( forward \"/books\" Books.Controller.resource ) into browserRouter in Router.fs file Start application by running build.cmd Run from the root of solution. This will start application in watch mode (automatic recompilation on changes) and open browser on http://localhost:8085 which should display index page. Go to http://localhost:8085/books to see generated view. All buttons should be working, you can add new entries, remove or edit old ones.","title":"How to start in 60 seconds"}]}